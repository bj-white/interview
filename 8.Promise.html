<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<body>
  <script>
    /******************
    Promise.resolve()
    .then(() => {
      return new Error('error!!!')
    })
    .then((res) => {
      console.log('then: ', res) // 输出
    })
    .catch((err) => {
      console.log('catch: ', err)
    })

    Promise.resolve(1)
    .then(2)
    .then(Promise.resolve(3))
    .then(console.log)
    // 输出1 .then期望的是函数，如果不是函数则会透传
     * 
    */
    /*
    Promise.then得第二个参数和Promise.catch效果一样，但.catch能捕捉.then得报错，第二个参数却不行。
    .all以慢的为准，一旦又失败，整体失败
    .race以快的为准，一旦又失败，整体失败
    */
    function Promise (executor) {
      this.status = 'panding';
      this.value = undefined;
      this.reason = undefined;

      this.onResolvedCallbacks = [];
      this.onRejectedCallbacks = [];

      function resolve (value) {
        this.status = 'resolve';
        this.value = value;
        this.onResolvedCallbacks.forEach(fun => {
          fun(this.value);
        });
      }
      function reject (reason) {
        this.status = 'reject';
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fun => {
          fun(this.reason);
        });
      }

      executor(resolve.bind(this), reject.bind(this));
    }
    Promise.prototype.then = function (onFulFilled, onRejected) {
      /* if (this.status == 'resolve') {
        onFulFilled(this.value);
      }
      if (this.status == 'reject') {
        onRejected(this.reason);
      } */
      return new Promise((resolve, reject) => {
        if (this.status == 'panding') {
          this.onResolvedCallbacks.push(function (value) {
            var result = onFulFilled(value);
            result && result.then((x) => {
              resolve(x);
            });
          });
          this.onRejectedCallbacks.push(onRejected);
        }
      });
    };

    var p1 = new Promise((resolve, reject) => {
      // resolve(1);
      setTimeout(() => {
        resolve(1);
        // reject('error');
      }, 0);
    });

    p1.then((response) => {
      console.log(response);
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve(2);
        }, 0);
      });
    }, (error) => {
      console.log(error);
    }).then((response) => {
      console.log(response);
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve(3);
        }, 0);
      });
    }, (error) => {
      console.log(error);
    }).then((response) => {
      console.log(response);
    }, (error) => {
      console.log(error);
    });
    // console.log(p1);
  </script>
</body>
</html>